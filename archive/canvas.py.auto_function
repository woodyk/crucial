#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# File: canvas.py
# Author: Wadih Khairallah
# Description: 
# Created: 2025-05-08 02:35:36
# Modified: 2025-05-08 02:37:29
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# File: canvas.py
# Description: Crucial Canvas class with DB-integrated action logging and dynamic method support
# Author: Ms. White
# Updated: 2025-05-07

import os
import json
import uuid
from datetime import datetime
from types import MethodType
from PIL import Image, ImageDraw

from crucial.config import CONFIG, get_logger
from crucial.db import get_db_connection
from crucial.utils.human_id import generate_human_id
from crucial.registry import load_all_schemas

logger = get_logger(__name__)


class Canvas:
    def __init__(self, name, width, height, bg_color):
        self.id = str(uuid.uuid4())
        self.name = name
        self.width = width
        self.height = height
        self.bg_color = bg_color
        self.created_at = datetime.utcnow().isoformat()
        self._init_db()
        logger.info("Initialized canvas '%s' (%s) %dx%d bg=%s",
                    self.name, self.id, self.width, self.height, self.bg_color)

    def _init_db(self):
        conn = get_db_connection()
        cur = conn.cursor()
        self.human_id = generate_human_id()
        cur.execute(
            "INSERT INTO canvases (id, human_id, name, width, height, background, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
            (self.id, self.human_id, self.name, self.width, self.height, self.bg_color, self.created_at)
        )
        conn.commit()
        logger.debug("Canvas DB entry created: %s", self.id)

    def _store_action(self, action_type, parameters, overwrite=False):
        logger.info("Canvas[%s] action: %s(%s)", self.id, action_type, parameters)
        conn = get_db_connection()
        cur = conn.cursor()
        if overwrite:
            cur.execute("DELETE FROM actions WHERE canvas_id = ?", (self.id,))
            logger.debug("Canvas[%s] previous actions cleared (overwrite=True)", self.id)
        timestamp = datetime.utcnow().isoformat()
        cur.execute(
            "INSERT INTO actions (canvas_id, timestamp, action, params) VALUES (?, ?, ?, ?)",
            (self.id, timestamp, action_type, json.dumps(parameters))
        )
        conn.commit()
        logger.debug("Canvas[%s] action logged: %s", self.id, action_type)

    def _mark_type(self, type_name):
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("PRAGMA table_info(canvases)")
        columns = {row[1] for row in cur.fetchall()}
        if "canvas_type" not in columns:
            cur.execute("ALTER TABLE canvases ADD COLUMN canvas_type TEXT")
            logger.debug("Added 'canvas_type' column to canvases table")
        cur.execute("UPDATE canvases SET canvas_type = ? WHERE id = ?", (type_name, self.id))
        conn.commit()
        logger.info("Canvas[%s] type marked as: %s", self.id, type_name)

    def clear(self, canvas_id):
        self._store_action("canvas_clear", {"canvas_id": canvas_id})

    def save(self, file_path=None, format="png"):
        """
        Save the canvas to disk as an image file.
        """
        output_dir = CONFIG["SAVE"]["output_dir"]
        os.makedirs(output_dir, exist_ok=True)

        filename = file_path or f"{self.id}.{format.lower()}"
        if not filename.lower().endswith(f".{format.lower()}"):
            filename += f".{format.lower()}"
        full_path = os.path.join(output_dir, filename)

        image = Image.new("RGB", (self.width, self.height), self.bg_color)
        draw = ImageDraw.Draw(image)
        # Future: replay actions here into the image

        image.save(full_path, format=format.upper())
        logger.info("Canvas[%s] saved to %s", self.id, full_path)

        return full_path

    @staticmethod
    def create(name: str, width: int, height: int, bg_color: str):
        """
        Factory method to create and persist a new Canvas instance.
        """
        canvas = Canvas(name, width, height, bg_color)
        return canvas

    def render_threejs(self, script):
        self._mark_type("threejs")
        self._store_action("render_threejs", {
            "canvas_id": self.id,
            "script": script
        }, overwrite=True)
        logger.info("Canvas[%s] rendered via ThreeJS", self.id)


    @staticmethod
    def resolve_id(identifier: str) -> str:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT id FROM canvases WHERE human_id = ?", (identifier,))
        row = cur.fetchone()
        if row:
            logger.debug("Resolved human_id %s â†’ %s", identifier, row["id"])
            return row["id"]
        logger.debug("Assuming %s is UUID", identifier)
        return identifier

    @staticmethod
    def from_id(canvas_id: str):
        resolved_id = Canvas.resolve_id(canvas_id)
        cur = get_db_connection().cursor()
        cur.execute("SELECT * FROM canvases WHERE id = ?", (resolved_id,))
        row = cur.fetchone()
        if not row:
            logger.warning("Canvas not found for ID: %s", canvas_id)
            return None
        canvas = Canvas.__new__(Canvas)
        canvas.id = row["id"]
        canvas.human_id = row["human_id"]
        canvas.name = row["name"]
        canvas.width = row["width"]
        canvas.height = row["height"]
        canvas.bg_color = row["background"]
        canvas.created_at = row["created_at"]
        logger.debug("Canvas object loaded: %s (%s)", canvas.name, canvas.id)
        return canvas


# --- Auto-generate methods for all schemas ---
def _inject_schema_methods(cls):
    schemas = load_all_schemas()
    for action_name in schemas.keys():
        if hasattr(cls, action_name):
            continue  # Don't override existing methods

        def make_method(action):
            def method(self, **kwargs):
                self._store_action(action, kwargs)
            method.__name__ = action
            method.__doc__ = f"Dynamically generated canvas method for {action}."
            return method

        setattr(cls, action_name, make_method(action_name))
    return cls

Canvas = _inject_schema_methods(Canvas)

